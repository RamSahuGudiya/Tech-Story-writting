
Explaining Kubernetes To My Uber Driver


A week ago, I attended Kubecon 2023 in Chicago. 
I read a few blogs and attended some 101 tutorials at the conference,
but still didnâ€™t have a good understanding of the technology. 
The worst part was the last day of the conference - I ordered an Uber to bring me back to my hotel.
My driver asked me â€œWhatâ€™s the convention about?â€ to which I responded â€œItâ€™s about Kubernetes",
but after some explaining, it was clear I had no idea what I was talking about.

Imagine coming out of a 3 day conference, 
and not being able to describe the technology to your Uber driver. 
Facepalm. So, in an attempt to redeem myself, hereâ€™s my reimagined conversation with my Uber driver.

Start of Conversation
Me: Imagine youâ€™re a chef at a busy restaurant kitchen. 
Youâ€™ve got a team of chefs working for you, and each one is preparing a different part of the meal - one group for appetizers, 
one for main courses, and another for desserts.
Coordinating these chefs to make sure the meal is served to the customer on time is your job.
You have a picture in your head?

Driver: Got it.

Me: In this scenario, the head chef is Kubernetes.
Just like that head chef needs to manage all the different chefs in the kitchen,
Kubernetes helps manage all the different pieces needed to run your software. 
The official definition of Kubernetes is a â€œcontainer-orchestration toolâ€, 
but since the word â€œcontainerâ€ is pretty abstract here, you can substitute the word â€œcontainerâ€ for â€œchefâ€. 
So Kubernetes would be a "chef orchestration tool".
That way, you can form a picture in your head of your kitchen every time you hear the word.

Driver: Okay, makes sense so far. But what are these containers? I can't keep imagining them as chefs forever.

Me: Yeah good point. So now that you have a picture in your head of your Kubernetes kitchen,
letâ€™s dive into how all the different kitchen roles map to Kubernetes concepts, going from smallest to largest.

Container
The smallest part of this puzzle is the container, and itâ€™s basically any piece of software.
For example, it could be a Node.js web server that hosts a web application, 
or a MongoDB database container to store data (this sentence is more for the engineers reading this blog,
I wouldnâ€™t say this to my Uber driver ğŸ˜›). In the kitchen,
imagine youâ€™re serving soup and a salad for your appetizer. The soup would be your container. 
The salad would also be its own container.

I know this definition seems a bit arbitrary right now,
but itâ€™ll make more sense once I explain it in the context of the upcoming components.

Pod
In the kitchen, a pod would be the plate/tray that holds your soup and salad.
In Kubernetes, a pod is something that can hold 1 or more containers. 
The reason for this is that containers within a pod can communicate with each other.

For the engineers: as an example, imagine I have a container for a web server and a container for a database in my pod. 
They can communicate with each other over localhost.

As for an appropriate analogy with the kitchen, I canâ€™t really think of anything. 
Imagine some Sausage Party shenanigans where your anthropomorphized soup and salad start chatting to each other. 
But the soup and salad from the appetizer plate canâ€™t talk to the steak and potatoes on the dinner plate
because they are on different plates (aka, different pods donâ€™t share the same network namespace
and therefore canâ€™t communicate with each other.)

Master Node
The head chef who manages and oversees the entire kitchen. 
This is that concept of â€œcontainer orchestrationâ€ or â€œchef orchestrationâ€ we talked about earlier. 
Some real life examples of the orchestration work that this master node would do would be:

Scaling, aka adjusting up or down the number of running pods based on CPU utilization. In a busy kitchen, 
when thereâ€™s a surge in customer demand, chefs may need to scale up their operations by preparing more servings of a dish.
By the way, one thing to note in this visualization - youâ€™re probably imagining the kitchen hiring in new chefs,
but I want you to imagine it more like the current chefs are getting cloned. When scaling happens, 
pods are essentially being copied.

Automated deployment, aka defining your applicationâ€™s dependencies & runtime instructions in a YAML file
so it can deploy based off this configuration. In a kitchen, 
this YAML file is analogous to a written recipe that tells the chef how to make the dish
to ensure consistency and efficiency and preparing it.

Load balancing, aka distributing network traffic across different pods.
In kitchen, load balancing involved assigning tasks to different chefs at a cooking station.
Maybe Bob at the dessert station is overloaded with requests to scoop ice cream, 
so the master chef clones Bob and has Bob 2.0 take some of the ice cream orders off Bob 1.0â€™s hands.
